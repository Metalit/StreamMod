// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.4.1
//   protoc               v4.25.1
// source: stream.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "";

export interface Settings {
  horizontal: number;
  vertical: number;
  /** in kbps */
  bitrate: number;
  fps: number;
  fov: number;
  mic: boolean;
  smoothness: number;
  fpfc: boolean;
}

export interface VideoFrame {
  data: Uint8Array;
}

export interface AudioFrame {
  channels: number;
  sampleRate: number;
  data: number[];
}

export interface Input {
  dx: number;
  dy: number;
  mouseDown: boolean;
  mouseUp: boolean;
  scroll: number;
  keysDown: string[];
  keysUp: string[];
}

export interface PacketWrapper {
  Packet?:
    | { $case: "settings"; value: Settings }
    | { $case: "videoFrame"; value: VideoFrame }
    | { $case: "audioFrame"; value: AudioFrame }
    | { $case: "input"; value: Input }
    | undefined;
}

function createBaseSettings(): Settings {
  return { horizontal: 0, vertical: 0, bitrate: 0, fps: 0, fov: 0, mic: false, smoothness: 0, fpfc: false };
}

export const Settings: MessageFns<Settings> = {
  encode(message: Settings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.horizontal !== 0) {
      writer.uint32(8).uint32(message.horizontal);
    }
    if (message.vertical !== 0) {
      writer.uint32(16).uint32(message.vertical);
    }
    if (message.bitrate !== 0) {
      writer.uint32(24).uint32(message.bitrate);
    }
    if (message.fps !== 0) {
      writer.uint32(37).float(message.fps);
    }
    if (message.fov !== 0) {
      writer.uint32(45).float(message.fov);
    }
    if (message.mic !== false) {
      writer.uint32(48).bool(message.mic);
    }
    if (message.smoothness !== 0) {
      writer.uint32(61).float(message.smoothness);
    }
    if (message.fpfc !== false) {
      writer.uint32(64).bool(message.fpfc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.horizontal = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vertical = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.bitrate = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.fps = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.fov = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.mic = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.smoothness = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.fpfc = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Settings>, I>>(base?: I): Settings {
    return Settings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Settings>, I>>(object: I): Settings {
    const message = createBaseSettings();
    message.horizontal = object.horizontal ?? 0;
    message.vertical = object.vertical ?? 0;
    message.bitrate = object.bitrate ?? 0;
    message.fps = object.fps ?? 0;
    message.fov = object.fov ?? 0;
    message.mic = object.mic ?? false;
    message.smoothness = object.smoothness ?? 0;
    message.fpfc = object.fpfc ?? false;
    return message;
  },
};

function createBaseVideoFrame(): VideoFrame {
  return { data: new Uint8Array(0) };
}

export const VideoFrame: MessageFns<VideoFrame> = {
  encode(message: VideoFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<VideoFrame>, I>>(base?: I): VideoFrame {
    return VideoFrame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoFrame>, I>>(object: I): VideoFrame {
    const message = createBaseVideoFrame();
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAudioFrame(): AudioFrame {
  return { channels: 0, sampleRate: 0, data: [] };
}

export const AudioFrame: MessageFns<AudioFrame> = {
  encode(message: AudioFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channels !== 0) {
      writer.uint32(8).uint32(message.channels);
    }
    if (message.sampleRate !== 0) {
      writer.uint32(16).uint32(message.sampleRate);
    }
    writer.uint32(26).fork();
    for (const v of message.data) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channels = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sampleRate = reader.uint32();
          continue;
        }
        case 3: {
          if (tag === 29) {
            message.data.push(reader.float());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.data.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<AudioFrame>, I>>(base?: I): AudioFrame {
    return AudioFrame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioFrame>, I>>(object: I): AudioFrame {
    const message = createBaseAudioFrame();
    message.channels = object.channels ?? 0;
    message.sampleRate = object.sampleRate ?? 0;
    message.data = object.data?.map((e) => e) || [];
    return message;
  },
};

function createBaseInput(): Input {
  return { dx: 0, dy: 0, mouseDown: false, mouseUp: false, scroll: 0, keysDown: [], keysUp: [] };
}

export const Input: MessageFns<Input> = {
  encode(message: Input, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dx !== 0) {
      writer.uint32(13).float(message.dx);
    }
    if (message.dy !== 0) {
      writer.uint32(21).float(message.dy);
    }
    if (message.mouseDown !== false) {
      writer.uint32(24).bool(message.mouseDown);
    }
    if (message.mouseUp !== false) {
      writer.uint32(32).bool(message.mouseUp);
    }
    if (message.scroll !== 0) {
      writer.uint32(45).float(message.scroll);
    }
    for (const v of message.keysDown) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.keysUp) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Input {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.dx = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.dy = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mouseDown = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.mouseUp = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.scroll = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.keysDown.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.keysUp.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Input>, I>>(base?: I): Input {
    return Input.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Input>, I>>(object: I): Input {
    const message = createBaseInput();
    message.dx = object.dx ?? 0;
    message.dy = object.dy ?? 0;
    message.mouseDown = object.mouseDown ?? false;
    message.mouseUp = object.mouseUp ?? false;
    message.scroll = object.scroll ?? 0;
    message.keysDown = object.keysDown?.map((e) => e) || [];
    message.keysUp = object.keysUp?.map((e) => e) || [];
    return message;
  },
};

function createBasePacketWrapper(): PacketWrapper {
  return { Packet: undefined };
}

export const PacketWrapper: MessageFns<PacketWrapper> = {
  encode(message: PacketWrapper, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.Packet?.$case) {
      case "settings":
        Settings.encode(message.Packet.value, writer.uint32(10).fork()).join();
        break;
      case "videoFrame":
        VideoFrame.encode(message.Packet.value, writer.uint32(18).fork()).join();
        break;
      case "audioFrame":
        AudioFrame.encode(message.Packet.value, writer.uint32(26).fork()).join();
        break;
      case "input":
        Input.encode(message.Packet.value, writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketWrapper {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketWrapper();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Packet = { $case: "settings", value: Settings.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.Packet = { $case: "videoFrame", value: VideoFrame.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Packet = { $case: "audioFrame", value: AudioFrame.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.Packet = { $case: "input", value: Input.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PacketWrapper>, I>>(base?: I): PacketWrapper {
    return PacketWrapper.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketWrapper>, I>>(object: I): PacketWrapper {
    const message = createBasePacketWrapper();
    if (object.Packet?.$case === "settings" && object.Packet?.value !== undefined && object.Packet?.value !== null) {
      message.Packet = { $case: "settings", value: Settings.fromPartial(object.Packet.value) };
    } else if (
      object.Packet?.$case === "videoFrame" && object.Packet?.value !== undefined && object.Packet?.value !== null
    ) {
      message.Packet = { $case: "videoFrame", value: VideoFrame.fromPartial(object.Packet.value) };
    } else if (
      object.Packet?.$case === "audioFrame" && object.Packet?.value !== undefined && object.Packet?.value !== null
    ) {
      message.Packet = { $case: "audioFrame", value: AudioFrame.fromPartial(object.Packet.value) };
    } else if (
      object.Packet?.$case === "input" && object.Packet?.value !== undefined && object.Packet?.value !== null
    ) {
      message.Packet = { $case: "input", value: Input.fromPartial(object.Packet.value) };
    }
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
